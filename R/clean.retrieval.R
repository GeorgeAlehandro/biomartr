#' @title Format \code{\link{meta.retrieval}} output
#' @description Process the output of \code{\link{meta.retrieval}} by first
#' un-zipping downloaded files and renaming them for more convenient downstream data analysis.
#' @param x a vector containing file paths to the output files generated by \code{\link{meta.retrieval}}.
#' @param gunzip a logical value indicating whether or not files should only be renamed (\code{gunzip = FALSE}) or renamed AND unzipped (\code{gunzip}).
#' @param clean.names a logical value indicating whether or not file names shall be cleaned (= renamed). \code{clean.names = TRUE} (Default). 
#' @author Hajk-Georg Drost
#' @details The output of \code{\link{meta.retrieval}} usually contains compressed sequence files
#' and a naming convention based on the database the respective file was retrieved from (e.g. \code{Saccharomyces_cerevisiae_cds_from_genomic_refseq.fna.gz}). 
#' This function helps to format the \code{\link{meta.retrieval}} output files by
#' \itemize{
#' \item 1) Automatically uncompress all sequence files in the \code{meta.retrieval} output folder
#' \item 2) Automatically rename files from e.g. \code{Saccharomyces_cerevisiae_cds_from_genomic_refseq.fna.gz} to \code{Scerevisiae.fa}.
#' This allows more convenient downstream analyses and visualizations.
#' }
#' @seealso \code{\link{meta.retrieval}}
#' @examples
#' \dontrun{
#' # The easiest way to use 'clean.retrieval()' in combination with
#' # 'meta.retrieval()' is to use the pipe operator from the 'magrittr' package
#' library(magrittr)
#' meta.retrieval(kingdom = "vertebrate_mammalian", 
#'                db = "refseq", 
#'                type = "genome") %>% clean.retrieval()
#' }
#' @export

clean.retrieval <- function(x, gunzip = TRUE, clean.names = TRUE) {
    
    if (any(!file.exists(x)))
        stop("Some of the meta.retrieval() output files seem not to exist. Please provide valid file paths to meta.retrieval() output files.", call. = FALSE)
    
    if (gunzip)
        message("Cleaning file names and unzipping files ...")
    
    if (!gunzip)
        message("Cleaning file names ...")
    
    folder_files <- list.files(dirname(x)[1])
    
    if (length(folder_files) == 0)
        stop("Unfortunately, your specified folder '", x, "' does not include any files.", call. = FALSE)
    
    # remove doc, md5checksum files, and already unzipped files
    find_doc <- which(stringr::str_detect(folder_files, "doc_"))
    find_md5 <- which(stringr::str_detect(folder_files, "md5checksum"))
    find_documentaion <- which(stringr::str_detect(folder_files, "documentation"))
    find_unzipped_files <- which(stringr::str_detect(folder_files, "[.]fa$"))
        
    if (length(c(find_doc, find_md5, find_documentaion, find_unzipped_files)) > 0) {
        folder_files_reduced <- folder_files[-c(find_doc, find_md5, find_documentaion, find_unzipped_files)]
    } 
    
    if (length(folder_files_reduced) == 0) {
        message("It seems that nothing needs to be done. All files are unzipped.")
        return(file.path(x, folder_files[-c(find_doc, find_md5, find_documentaion)]))
    } else {
        input_files <- folder_files_reduced
    }  
    
    input_files_without_appendix <- unlist(lapply(input_files, function(x) return(unlist(stringr::str_split(x, "[.]"))[1])))
    
    if (gunzip)
        output_files <- paste0(tidy_name(input_files_without_appendix),".fa")
    
    if (!gunzip)
    output_files <- paste0(tidy_name(input_files_without_appendix),".fa.gz")
    
    if (!all(file.exists(file.path(x, input_files))))
        stop("Something went wrong during the cleaning process. Some input files seem not to exist.", call. = FALSE)
    
    if (clean.names)
        file.rename(file.path(x, input_files), file.path(x, output_files))
    
    if (gunzip) {
        for (i in seq_len(length(output_files))) {
            if (file.exists(file.path(x, output_files[i]))) {
                message("Unzipping file ", output_files[i],"' ...")
                R.utils::gunzip(file.path(x, output_files[i]))   
            }
        }
    }
    
    message("Finished formatting.")
    
    return(file.path(x, output_files))
}
